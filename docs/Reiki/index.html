<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (Reiki.index)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="..">Up</a> ‚Äì <a href="../">Reiki</a> &#x00BB; index</nav></header><h2 id="top"><a href="#top" class="anchor"></a>üßò reiki</h2><p><code>status: usable ALPHA</code>.</p><p>Reiki is an idiomatic ReasonML wrapper around the <a href="https://yogalayout.com/"><code>yoga-layout</code></a> node package by Facebook.</p><p>It provides a comfortable, functional API to writting layouts.</p><p>For the main documentation please visit: <a href="http://yogalayout.com/docs">Yoga Layout Docs</a>.</p><pre><code class="ml">let {top, left, width, height} : Yoga.Node.computed_layout = Yoga.Node.(
  create({
    width: Window.width,
    height: Window.height,
    justify_content: Flex_start,
    flex_direction: Column,
    align_items: Flex_start,
  })
  |&gt; insertChild(nav.node, 0)
  |&gt; insertChild(footer.node, 0)
  |&gt; calculateLayout({
       width: Window.width,
       height: Window.height,
       direction: Left_to_right,
     })
);</code></pre><h3 id="catalog"><a href="#catalog" class="anchor"></a>List of Modules</h3><ul><li><a href="Yoga"><code>Yoga</code></a></li></ul><h3 id="motivation"><a href="#motivation" class="anchor"></a>Motivation</h3><p>Before we dig into how to use this library, let's do a small concept overview of why do we want to use a layouting like Yoga.</p><p>Yoga a solution to rolling out your own layouting engine that will work in a cross-platform way, efficiently, and preserving semantics.</p><p>By this I mean, the layout you define in your web application can be reused in your mobile applications or in native applications, and it will run efficiently everywhere, without needing to make significant changes to preserve the constraints you specified.</p><p>That is, if you say that your <code>navbar</code> should be stretched horizontally across the screen, with it's children centered and evenly spaced according, you don't need to say <em>the same thing</em> but <em>in a different way</em>.</p><p>With this in mind, Yoga works in 3 steps:</p><ol><li><a href="#motivation-step-1">Declaring Constraints</a></li><li><a href="#motivation-step-2">Recalculating the Layout</a></li><li><a href="#motivation-step-3">Accessing the Computed Layout</a></li></ol><p>For more info on how each step looks with <code>Reiki</code>, keep reading onto <a href="#getting-started">Getting Started</a>.</p><h4 id="motivation-step-1"><a href="#motivation-step-1" class="anchor"></a>Declaring Constraints</h4><p>First, we will build up a <em>layouting forest</em>. That is, you will normally have one or multiple <code>root nodes</code> that will represent contexts for the rest of your application to be attached to. These <code>nodes</code> will be inserted children, which are really just more <code>nodes</code>.</p><h4 id="motivation-step-2"><a href="#motivation-step-2" class="anchor"></a>Recalculating the Layout</h4><p>Once you have your layout constraints declared, you can take a <code>root node</code> and tell it to <em>recalculate the layout</em>. This will update all of the node's children according to the constraints declared.</p><h4 id="motivation-step-3"><a href="#motivation-step-3" class="anchor"></a>Accessing the Computed Layout</h4><p>Now that we have our computed layout available, we can access it and use it's coordinate and sizing attributes (such as <code>{top, left, width, height, ...}</code>) to apply this layout to CSS, SVG, Canvas, WebGL, Cocoa, wxWidgets, GTK+, SDL, OpenGL, DirectX, or whichever library or framework that will take care of actually showing things on a screen.</p><h3 id="getting-started"><a href="#getting-started" class="anchor"></a>Getting Started</h3><p>The core of the Reiki package is the <a href="Yoga/Node"><code>Yoga.Node</code></a> module. In it you'll find a handful of utility functions for dealing with <code>nodes</code>. In this intro we will visit 4: <a href="Yoga/Node#val-create"><code>Yoga.Node.create</code></a>, <a href="Yoga/Node#val-insertChild"><code>Yoga.Node.insertChild</code></a>, <a href="Yoga/Node#val-calculateLayout"><code>Yoga.Node.calculateLayout</code></a>, and <a href="Yoga/Node#val-computedLayout"><code>Yoga.Node.computedLayout</code></a>.</p><p>Let's create our root node, giving it the size of the current viewport, and arranging the content inside of it to be at the beginning of the flexed containers, with it's internal elements stacked in a column (as opposed to a row), and aligning them with the beginning of the flexed container.</p><p>&gt; Note: if this lingo feels strange, feel free to have a look at &gt; <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">CSS Trick's &gt; Complete Guide to Flexbox</a>. It might make some of it clearer! Otherwise feel &gt; free to <a href="https://github.com/ostera/reiki/issues/new">open an Github Issue</a> &gt; and we can work on rephrasing it üôåüèº</p><pre><code class="ml">let root = Yoga.Node.create({
  width: Window.width,
  height: Window.height,
  justify_content: Flex_start,
  flex_direction: Column,
  align_items: Flex_start,
});</code></pre><p>Great, with our <code>root node</code> in place, we can define our <code>navbar</code> node. This node should be as wide as the screen, but have a fixed height, and keep all of it's content in a single row, centered, but equidistantly spaced:</p><pre><code class="ml">let navbar = Yoga.Node.create({
  width: Window.width,
  height: 100,
  justify_content: Space_between,
  flex_direction: Row,
  align_items: Center,
});</code></pre><p>Now we can insert this node into our <code>root</code>:</p><pre><code class="ml">Yoga.Node.insertChild(navbar, 1, root) |&gt; ignore;</code></pre><p>It is worth noting that while the API for `insertChild` is designed to piping convenience (data-last, and returns the same node), internally the library is actually mutating the node.</p><p>After this we can recompute the complete layout by asking the <code>root</code> to recalculate it's layout on a particular context (<a href="Yoga/Node#type-ctx"><code>Yoga.Node.ctx</code></a>):</p><pre><code class="ml">Yoga.Node.calculateLayout({
  width: Window.width,
  height: Window.height,
  direction: Left_ro_right,
}, root);</code></pre><p>Now each <code>node</code> under the parenthood of our <code>root node</code> will have it's computed layout updated! We can access it using <a href="Yoga/Node#val-computedLayout"><code>Yoga.Node.computedLayout</code></a>:</p><pre><code class="ml">let root_layout = root |&gt; Yoga.Node.computedLayout;
let nav_layout = navbar |&gt; Yoga.Node.computedLayout;</code></pre><p>And we can use the properties <code>{ top, left, width, height }</code> top position and size our root component and our navigation component!</p><p>Make sure to set your CSS styles to <code>position: absolute</code>!</p><h3 id="algebras"><a href="#algebras" class="anchor"></a>Algebras</h3><p>The keen observer might have noticed that <code>nodes</code> seem to form <em>monoids</em>. I'm still exploring the application of these abstractions, but if they pan out nicely, a <span class="xref-unresolved" title="unresolved reference to &quot;Yoga.Operators&quot;"><a href="Yoga"><code>Yoga</code></a>.Operators</span> package will be provided. I'd very much like to concisely recompute my layouts:</p><pre><code class="ml">open Yoga.Operators;

let computed_layout = root &lt;+&gt; nav &lt;+&gt; side &lt;+&gt; content &lt;+&gt; footer *&gt; context</code></pre></div></body></html>